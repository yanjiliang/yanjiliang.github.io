import{_ as e,c as a,o as t,a3 as n}from"./chunks/framework.Dcugq_a2.js";const _=JSON.parse('{"title":"工具","description":"","frontmatter":{},"headers":[],"relativePath":"web2/pack-tools/index.md","filePath":"web2/pack-tools/index.md"}'),i={name:"web2/pack-tools/index.md"},o=n(`<h1 id="工具" tabindex="-1">工具 <a class="header-anchor" href="#工具" aria-label="Permalink to &quot;工具&quot;">​</a></h1><h1 id="_1-微前端框架-qiankun-wujie对比" tabindex="-1">1. 微前端框架：qiankun/wujie对比 <a class="header-anchor" href="#_1-微前端框架-qiankun-wujie对比" aria-label="Permalink to &quot;1. 微前端框架：qiankun/wujie对比&quot;">​</a></h1><ul><li><h2 id="qiankun框架" tabindex="-1">qiankun框架 <a class="header-anchor" href="#qiankun框架" aria-label="Permalink to &quot;qiankun框架&quot;">​</a></h2></li></ul><p>基于single-spa封装，使用HTML Entry作为加载子应用的方式 沙箱机制： - 默认Proxy沙箱机制 &gt; 通过Proxy代理全局window对象，每个子应用激活时，拥有一个独立的window代理对象 &gt; 优点：性能好，有效隔离全局变量与函数 &gt; 缺点：兼容性差 - SnapShot沙箱机制 &gt; 通过快照的方式，在子应用激活时，对当前window对象进行快照，在子应用卸载时，将window对象恢复到快照状态 &gt; 优点：兼容性好 &gt; 缺点：性能差，需要频繁的快照与恢复 - Legacy沙箱机制 &gt; 通过iframe的方式，每个子应用激活时，创建一个iframe，将子应用加载到iframe中 &gt; 优点：兼容性好，性能好 &gt; 缺点：需要频繁的创建与销毁iframe，对主应用性能有一定影响 - Shadow DOM沙箱机制 &gt; 通过Shadow DOM的方式，每个子应用激活时，创建一个Shadow DOM，将子应用加载到Shadow DOM中 &gt; 优点：兼容性好，性能好 &gt; 缺点：需要频繁的创建与销毁Shadow DOM，对主应用性能有一定影响</p><p>样式隔离： - CSS Module &gt; 通过CSS Module的方式，每个子应用激活时，创建一个CSS Module，将子应用样式加载到CSS Module中 &gt; 优点：兼容性好，性能好 &gt; 缺点：需要频繁的创建与销毁CSS Module，对主应用性能有一定影响</p><pre><code>- Css-in-js
    &gt; 通过Css-in-js的方式，每个子应用激活时，创建一个Css-in-js，将子应用样式加载到Css-in-js中
    &gt; 优点：兼容性好，性能好
    &gt; 缺点：需要频繁的创建与销毁Css-in-js，对主应用性能有一定影响

- 动态创建样式前缀
    &gt; 通过动态创建样式前缀的方式，每个子应用激活时，创建一个样式前缀，将子应用样式加载到样式前缀中
    &gt; 优点：兼容性好，性能好
    &gt; 缺点：需要频繁的创建与销毁样式前缀，对主应用性能有一定影响
</code></pre><p>可以使用loadMicroApp加载子应用</p><ul><li><h2 id="wujie框架" tabindex="-1">wujie框架 <a class="header-anchor" href="#wujie框架" aria-label="Permalink to &quot;wujie框架&quot;">​</a></h2></li></ul><p>基于Web Component和iframe的方式实现 将子应用的JS在主应用的iframe中加载，实现JS隔离，子应用实例instance，DOM使用web component添加到主应用容器内，通过代理iframe的document到web component，可以实现两者互联 子应用保留iframe和Web component，应用内的state保留，从而实现应用保活。</p><p>通信机制： - props - window.parent - event bus</p><p>路由同步 劫持iframe的pushState和replaceState，将子应用的URL同步到主应用的query中，当刷新浏览器初始化iframe时，读回子应用的url并使用iframe的history.replaceState同步</p>`,11),r=[o];function s(d,l,u,p,c,h){return t(),a("div",null,r)}const w=e(i,[["render",s]]);export{_ as __pageData,w as default};
