import{_ as s,c as i,o as a,a3 as t}from"./chunks/framework.Dcugq_a2.js";const g=JSON.parse('{"title":"面试题","description":"","frontmatter":{},"headers":[],"relativePath":"web2/react/interview.md","filePath":"web2/react/interview.md"}'),n={name:"web2/react/interview.md"},l=t(`<h1 id="面试题" tabindex="-1">面试题 <a class="header-anchor" href="#面试题" aria-label="Permalink to &quot;面试题&quot;">​</a></h1><h1 id="_1、react18有哪些新特性" tabindex="-1">1、React18有哪些新特性？ <a class="header-anchor" href="#_1、react18有哪些新特性" aria-label="Permalink to &quot;1、React18有哪些新特性？&quot;">​</a></h1><ul><li>自动批处理（Automatic batching）</li><li>并发渲染（Concurrent rendering）</li><li>异步渲染（Suspense for Data Fetching）</li><li>startTransition</li><li>useDeferredValue</li><li>useId</li><li>useTransition</li></ul><h1 id="_2、react19有哪些新特性" tabindex="-1">2、React19有哪些新特性？ <a class="header-anchor" href="#_2、react19有哪些新特性" aria-label="Permalink to &quot;2、React19有哪些新特性？&quot;">​</a></h1><h1 id="_3、react合成事件-syntheticevent" tabindex="-1">3、React合成事件 SyntheticEvent <a class="header-anchor" href="#_3、react合成事件-syntheticevent" aria-label="Permalink to &quot;3、React合成事件 SyntheticEvent&quot;">​</a></h1><div class="info custom-block"><p class="custom-block-title">INFO</p><p>React搞出合成事件这个东西，最主要的是要做跨平台cross-browser,抹平各个浏览器之间的差异。官方文档也是这么说的 a cross-browser wrapper around the browser&#39;s native event. 把浏览器的原生事件进行了包裹，使得在各个浏览器可以保持统一的执行逻辑。 React normalizes events so that they have consistent properties across different browsers.</p></div><h1 id="_4、介绍下hoc" tabindex="-1">4、介绍下HOC <a class="header-anchor" href="#_4、介绍下hoc" aria-label="Permalink to &quot;4、介绍下HOC&quot;">​</a></h1><div class="info custom-block"><p class="custom-block-title">INFO</p><p>React HOC是一个用于复用组件逻辑的函数，它接收一个组件作为参数，并返回一个新的组件，新组件会拥有原始组件的所有功能，并且可以对原始组件的功能进行扩展。</p></div><h1 id="_5-介绍下mutationobserver" tabindex="-1">5. 介绍下MutationObserver <a class="header-anchor" href="#_5-介绍下mutationobserver" aria-label="Permalink to &quot;5. 介绍下MutationObserver&quot;">​</a></h1><blockquote><p>浏览器的MutationObserver API</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 回调函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mutationsList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">observer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // mutationsList 是一个数组，包含所有变动的节点</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // observer 是一个MutationObserver实例，包含有 observe() 方法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mutation </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mutationsList) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mutation.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;childList&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 子节点变动</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (mutation.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;attributes&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 属性变动</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个观察者实例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> observer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MutationObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cb)</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> config</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    attrubutes: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 观察属性变动</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    characterData: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 观察文本内容变动</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    childList: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 观察子节点变动</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    subtree: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 观察所有后代节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    attributeOldValue: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 观察属性变动的旧值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    characterDataOldValue: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 观察</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> targetNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;test&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(targetNode, config);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 停止观察</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disconnect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><div class="warning custom-block"><p class="custom-block-title">WARNING</p><ul><li>使用MutationObserver应该慎用，如果监听的是大型DOM树或频繁变动，会产生性能问题</li><li>最好精确指定需要观察的变动type和节点，例如config中的childList和attributes</li></ul></div><h1 id="_6-常见的样式隔离有哪些" tabindex="-1">6. 常见的样式隔离有哪些？ <a class="header-anchor" href="#_6-常见的样式隔离有哪些" aria-label="Permalink to &quot;6. 常见的样式隔离有哪些？&quot;">​</a></h1><ul><li>CSS Modules: 在构建时将CSS类名局部作用域化。通常通过添加哈希值来实现，当导入一个CSS模块，会得到一个包含生成的类名的对象。这样可以确保样式的唯一性，防止样式冲突。</li><li>Shadow DOM：Web components规范，允许将一段不受外界影响的DOM附加到元素上，Shadow DOM的样式是局部的，不会影响外部的文档样式。</li><li>CSS-in-JS：使用JavaScript来生成CSS类名，可以实现样式的局部作用域和样式隔离。</li><li>BEM block element modifier：BEM是一种前端命名约定的方式，通过给元素添加前缀、后缀和修饰符来确保样式的唯一性和可维护性。</li><li>CSS Scoped：CSS Modules的语法糖，通过在HTML标签上添加一个特殊的属性来将CSS样式限制在当前组件中。</li><li>iframe：iframe本身的样式、脚本隔离。但使用过多会有性能问题，并且组件通信较为困难</li><li>postCSS：自动为CSS添加唯一前缀、变量等从而实现隔离</li><li>封装的CSS架构：准确的使用CSS选择器，严格的CSS命名规范</li></ul><h1 id="_7-portals是什么-使用场景有哪些" tabindex="-1">7. Portals是什么？使用场景有哪些？ <a class="header-anchor" href="#_7-portals是什么-使用场景有哪些" aria-label="Permalink to &quot;7. Portals是什么？使用场景有哪些？&quot;">​</a></h1><p>React Portals提供了一种将子节点渲染到父组件之外的DOM节点。通常组件的渲染输出会被插入到其父组件下，但是Portals提供了一种穿透组件层次结构，直接渲染到任意DOM节点的方法</p><ul><li>【父子结构逃逸】：允许将子组件渲染到父组件的DOM结构之外的DOM节点上</li><li>【样式继承独立】：可以不受父组件样式的影响，易于控制和自定义样式</li><li>【事件冒泡正常】：可以正常触发事件冒泡</li></ul><p>使用场景：</p><ul><li>模态框组件</li><li>浮动菜单</li><li>提示、通知组件</li><li>全屏组件</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ReactDOM.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createPortal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(child, container);</span></span></code></pre></div><h1 id="_8-react和react-dom的区别" tabindex="-1">8. React和React-DOM的区别？ <a class="header-anchor" href="#_8-react和react-dom的区别" aria-label="Permalink to &quot;8. React和React-DOM的区别？&quot;">​</a></h1><p>ReactDOM是React库的一部分，专门用于与浏览器DOM交互，包括DOM的渲染、更新和删除。</p>`,22),e=[l];function h(p,k,r,c,d,E){return a(),i("div",null,e)}const y=s(n,[["render",h]]);export{g as __pageData,y as default};
